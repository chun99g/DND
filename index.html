loader.load(GLB_FILES[sides], (gltf) => {
                const model = gltf.scene;

                // --- 自動修正大小與位置 (Auto-Fit) ---
                const box = new THREE.Box3().setFromObject(model);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());

                // 1. 把模型歸零置中
                model.position.x += (model.position.x - center.x);
                model.position.y += (model.position.y - center.y);
                model.position.z += (model.position.z - center.z);

                // 2. 計算縮放比例 (強制把骰子最大的邊長縮放到 3 單位大)
                const maxDim = Math.max(size.x, size.y, size.z);
                const scaleFactor = 3.0 / maxDim; 
                model.scale.set(scaleFactor, scaleFactor, scaleFactor);

                // 3. 確保材質稍微亮一點 (避免全黑)
                model.traverse((child) => {
                    if (child.isMesh) {
                        child.frustumCulled = false; // 防止被錯誤裁切
                        if (child.material) {
                            child.material.emissive = new THREE.Color(0x222222); // 加一點自發光
                            child.material.side = THREE.DoubleSide; // 雙面渲染
                        }
                    }
                });

                model.visible = false;
                scene.add(model);
                diceModels[sides] = model;
                
                debugLog.innerText += `✅ D${sides} 載入成功 (原始大小:${maxDim.toFixed(2)} -> 修正縮放:${scaleFactor.toFixed(2)})\n`;
            }, undefined, (e) => {
                console.error(e);
                debugLog.innerText += `❌ D${sides} 載入失敗: ${e.message}\n`;
            });
